<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUMPER Burn — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard for BUMPER on Solana: total burned, USD value, price, and recent burn transactions." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <link rel="preload" as="image" href="bg-thumb.webp">
  <link rel="preload" as="image" href="titolo.png">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC      = 'bg-desktop.png';       // main background
    const THUMB_SRC   = 'bg-thumb.webp';        // small preview (optional but recommended)
    const TITLE_SRC   = 'titolo.png';           // title image
    const BURN_JSON   = 'data/burn.json';
    const PRICE_JSON  = 'data/price.json';
    const FIT_MODE    = 'cover'; // 'contain' to avoid any crop

    // Layout anchors (relative to canvas height)
    let TOP_OVERLAY_Y   = 0.12; // y for the two top cards
    let UPDATED_Y       = 0.62; // moved up: just under the car
    let BOTTOM_PRICE_Y  = 0.90;

    // Supply card custom anchor (desktop only)
    let SUPPLY_LEFT_X_PCT = 0.06; // 6% from left edge
    let SUPPLY_Y_PCT      = 0.58; // near the ground, under legionaries

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    // Canvas
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      if (h < 700) { TOP_OVERLAY_Y = 0.10; UPDATED_Y = 0.66; BOTTOM_PRICE_Y = 0.88; }
      else { TOP_OVERLAY_Y = 0.12; UPDATED_Y = 0.62; BOTTOM_PRICE_Y = 0.90; }
    }

    function scaleUnit() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      return Math.max(0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // -------- Progressive background loading (blur-up + crossfade) --------
    let thumbBitmap = null;
    let mainBitmap  = null;
    let bgReady = false;
    let fadeAlpha = 0; // 0..1

    async function loadBitmap(src){
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return await createImageBitmap(blob, { imageOrientation: 'none', premultiplyAlpha: 'default' });
      } catch (e) {
        console.warn('Image load failed:', src, e.message);
        return null;
      }
    }

    // Title image
    const titleImg = new Image();
    let titleReady = false;
    titleImg.onload = ()=>{ titleReady = true; draw(); };
    titleImg.onerror = ()=>{ console.warn('Failed to load title image:', TITLE_SRC); };
    titleImg.src = TITLE_SRC;

    // Start loading: thumb first, then main
    (async function initBackground(){
      thumbBitmap = await loadBitmap(THUMB_SRC); // may be null if file not provided
      draw();
      mainBitmap = await loadBitmap(BG_SRC);
      if (mainBitmap) {
        bgReady = true;
        const start = performance.now();
        function step(t){
          const k = Math.min(1, (t - start) / 450); // 450ms fade
          fadeAlpha = k;
          draw();
          if (k < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      } else {
        draw();
      }
    })();

    // Data
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, totalSupplyTokensNum/totalSupplyTokens, updatedAt? }

    let linkHitboxes = [];

    function cacheBust(url){ return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); }
    async function loadJson(url){ const res = await fetch(cacheBust(url), { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.json(); }
    async function refreshData(){
      try { const [b, p] = await Promise.all([ loadJson(BURN_JSON).catch(()=>null), loadJson(PRICE_JSON).catch(()=>null) ]); burn = b; price = p; }
      catch(e){ console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, px(12));
      ctx.fillStyle = COLOR.glass; ctx.fill();
      ctx.strokeStyle = COLOR.stroke; ctx.lineWidth = 1; ctx.stroke();
    }
    function text(opts){
      const { str, x, y, size=20, weight=400, color=COLOR.text, align='left', baseline='alphabetic' } = opts;
      ctx.fillStyle = color;
      ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = align; ctx.textBaseline = baseline;
      ctx.fillText(str, x, y);
    }
    function fitNumber(n, maxDp){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6); return n.toLocaleString(undefined, { maximumFractionDigits: dp }); }
    function money(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }); }

    function formatSupplyCompact(n){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      if (abs >= 1e9)  return (n/1e9).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' B';
      if (abs >= 1e6)  return (n/1e6).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' M';
      if (abs >= 1e3)  return (n/1e3).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' K';
      return n.toLocaleString(undefined,{ maximumFractionDigits: 3 });
    }

    function drawBackground(w, h){
      // Base gradient for readability
      const grad = ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');

      const showThumb = thumbBitmap && (!mainBitmap || fadeAlpha < 1);
      const bmp = (bgReady && mainBitmap) ? mainBitmap : (thumbBitmap || null);

      if (bmp){
        const imgW = bmp.width, imgH = bmp.height;
        const scale = (FIT_MODE === 'cover') ? Math.max(w / imgW, h / imgH) : Math.min(w / imgW, h / imgH);
        const dw = imgW * scale; const dh = imgH * scale;
        const dx = (w - dw) / 2; const dy = (h - dh) / 2;

        if (showThumb && thumbBitmap){
          ctx.save(); ctx.filter = 'blur(8px)';
          ctx.drawImage(thumbBitmap, dx, dy, dw, dh); ctx.restore();
        }
        if (bgReady && mainBitmap){
          ctx.save(); ctx.globalAlpha = fadeAlpha || 1; ctx.filter = 'none';
          ctx.drawImage(mainBitmap, dx, dy, dw, dh); ctx.restore();
        }
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
      } else {
        ctx.fillStyle = '#0b0b12'; ctx.fillRect(0,0,w,h);
      }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;

      ctx.clearRect(0,0,w,h);
      drawBackground(w, h);
      linkHitboxes = [];

      // --- Title image (centered above cards) ---
      const topY = Math.floor(h * TOP_OVERLAY_Y);
      if (titleReady){
        const maxW = Math.min(w * 0.5, px(640));
        const scale = maxW / titleImg.naturalWidth;
        const tw = maxW;
        const th = titleImg.naturalHeight * scale;
        const tx = Math.floor((w - tw) / 2);
        const ty = Math.max(px(14), topY - th - px(10));
        ctx.drawImage(titleImg, tx, ty, tw, th);
      } else {
        // fallback text title
        text({ str: 'BUMPER BURN', x: Math.floor(w/2), y: Math.max(px(24), topY - px(28)), size: px(34), weight: 900, align: 'center' });
      }

      // --- Top metrics (two cards) ---
      const cardW = Math.min(Math.max(px(300), Math.floor(w*0.28)), px(520));
      const cardH = px(84);
      const gap   = Math.min(px(24), Math.floor(w*0.04));
      const totalX = Math.floor((w - (cardW*2 + gap)) / 2);
      const usdX   = totalX + cardW + gap;

      drawGlass(totalX, topY, cardW, cardH);
      drawGlass(usdX,  topY, cardW, cardH);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);

      const padX = px(14), padY = px(12);
      text({ str: 'Total burned',        x: totalX+padX, y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: 'Total USD burned',    x: usdX+padX,   y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });

      text({ str: fitNumber(totalTokens, 6)+' BUMPER', x: totalX+padX, y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent,  baseline: 'top' });
      text({ str: money(totalUsd),                  x: usdX+padX,   y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent2, baseline: 'top' });

      // --- Supply card ---
      const supplyNum = (price && typeof price.totalSupplyTokensNum === 'number')
        ? price.totalSupplyTokensNum
        : (price && price.totalSupplyTokens ? Number(price.totalSupplyTokens) : 0);

      let supplyX, supplyY;
      if (w < 800) {
        // mobile/tablet: keep it centered below the two cards
        supplyY = topY + cardH + px(14);
        supplyX = Math.floor((w - cardW)/2);
      } else {
        // desktop: left-bottom by percentage anchors
        supplyY = Math.floor(h * SUPPLY_Y_PCT);
        supplyX = Math.floor(w * SUPPLY_LEFT_X_PCT);
      }

      drawGlass(supplyX, supplyY, cardW, cardH);
      text({ str: 'Total supply', x: supplyX+padX, y: supplyY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: formatSupplyCompact(supplyNum), x: supplyX+padX, y: supplyY+padY+px(32), size: px(22), weight: 800, color: COLOR.text, baseline: 'top' });

      // --- Last updated ---
      const updated = price?.updatedAt || burn?.updatedAt || null;
      if (updated){
        const u = new Date(updated).toLocaleString();
        text({ str: `Last updated: ${u}`, x: Math.floor(w/2), y: Math.floor(h*UPDATED_Y), size: px(12), color: COLOR.muted, weight: 700, align: 'center' });
      }

      // --- Bottom price ---
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const label = `BUMPER price: ${priceStr} USD`;
      ctx.font = `700 ${px(16)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const m = ctx.measureText(label);
      const bottomY = Math.floor(h * BOTTOM_PRICE_Y);
      const pad = px(10), bh = px(34), bw = m.width + pad*2;
      const bx = Math.floor((w - bw)/2), by = Math.floor(bottomY - bh/2);
      drawGlass(bx, by, bw, bh);
      text({ str: label, x: Math.floor(w/2), y: bottomY+1, size: px(16), weight: 700, align: 'center', baseline: 'middle' });

      // --- Burns table ---
      const rowsAll = (burn?.burns || []);
      const maxRows = w < 520 ? 8 : (w < 900 ? 12 : 20);
      const rows = rowsAll.slice(0, maxRows);

      const tableW = Math.min(Math.max(px(420), Math.floor(w*0.92)), px(1000));
      const rowH   = px(24), headH = px(32), tPad = px(10);
      const tableH = headH + Math.max(1, rows.length) * rowH + tPad*2;
      let tableX = Math.floor((w - tableW)/2);
      let tableY = Math.floor(h * (UPDATED_Y + 0.03));
      if (tableY + tableH > h - 12) tableY = h - 12 - tableH;

      drawGlass(tableX, tableY, tableW, tableH);
      text({ str: 'Recent burns', x: tableX+tPad, y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableW*0.28));
      const colLinkW  = tableW - tPad*2 - colIndexW - colQtyW;

      text({ str: '#',               x: tableX+tPad+6,                      y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (BUMPER)', x: tableX+tPad+colIndexW+8,            y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',     x: tableX+tPad+colIndexW+colQtyW+8,    y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      linkHitboxes = [];
      for (let i=0; i<Math.max(1, rows.length); i++){
        const ry = tableY + headH + tPad + i*rowH;
        if (rows.length === 0){ text({ str: 'No burns found.', x: tableX+tPad, y: ry, size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' }); break; }
        const row = rows[i]; const qty = Number(row.amountUi || 0); const url = row.url || '#';
        text({ str: String(i+1), x: tableX+tPad+6, y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
        text({ str: fitNumber(qty, 6), x: tableX+tPad+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });
        const linkStr = 'Open on Solscan';
        ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
        ctx.fillStyle = COLOR.link; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(linkStr, tableX+tPad+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
        const m2 = ctx.measureText(linkStr);
        linkHitboxes.push({ x: tableX+tPad+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m2.width, h: Math.floor(rowH*0.9), url });
      }
    }

    // Interactivity
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>
