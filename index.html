<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUMPER Burn — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard for BUMPER on Solana: total burned, USD value, price, and recent burn transactions." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <link rel="preload" as="image" href="bg-thumb.webp">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC      = 'bg-desktop.png';       // main background
    const THUMB_SRC   = 'bg-thumb.webp';        // small preview (optional)

    const BURN_JSON   = 'data/burn.json';
    const PRICE_JSON  = 'data/price.json';
    const FIT_MODE    = 'cover'; // 'contain' to avoid any crop

    // UI only when bg + data
    const DRAW_UI_ONLY_WHEN_READY = true;
    const USE_THUMB_PLACEHOLDER   = false;

    // ======== CARD POSITIONS (desktop, come da tue scelte) ========
    const CARDS_Y_FRAC = 0.1350;          // y fraction (under title, avoid car)
    const CARD1_CENTER_X_FRAC = 0.3220;   // Total burned (under BELLA)
    const CARD2_CENTER_X_FRAC = 0.6520;   // Total USD burned (under BURN)

    // ======== Mobile tuning ========
    const MOBILE_BREAKPOINT = 900;        // < 900px = mobile mode
    const MOBILE_CARDS_Y_FRAC = 0.13;     // posizione verticale card1 su mobile
    const MOBILE_CARDS_GAP_PX = 10;       // distanza tra card1 e card2 su mobile (px scalati)

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    // Canvas
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }

    function scaleUnit() {
      // consente di scalare più in basso su mobile
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      const isMobile = w < MOBILE_BREAKPOINT;
      return Math.max(isMobile ? 0.45 : 0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // -------- Progressive background loading (blur-up + crossfade) --------
    let thumbBitmap = null;
    let mainBitmap  = null;
    let bgReady = false;
    let fadeAlpha = 0; // 0..1

    async function loadBitmap(src){
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      } catch (e) {
        console.warn('Image load failed:', src, e.message);
        return null;
      }
    }

    // Load bg: thumb (optional) then main
    (async function initBackground(){
      thumbBitmap = await loadBitmap(THUMB_SRC); // may be null
      draw();
      mainBitmap = await loadBitmap(BG_SRC);
      if (mainBitmap) {
        bgReady = true;
        const start = performance.now();
        function step(t){
          const k = Math.min(1, (t - start) / 450);
          fadeAlpha = k; draw();
          if (k < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      } else { draw(); }
    })();

    // Data
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, totalSupplyTokensNum/totalSupplyTokens, updatedAt? }

    let linkHitboxes = [];

    function cacheBust(url){ return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); }
    async function loadJson(url){ const res = await fetch(cacheBust(url), { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.json(); }
    async function refreshData(){
      try { const [b, p] = await Promise.all([ loadJson(BURN_JSON).catch(()=>null), loadJson(PRICE_JSON).catch(()=>null) ]); burn = b; price = p; }
      catch(e){ console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath(); ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, px(12));
      ctx.fillStyle = COLOR.glass; ctx.fill();
      ctx.strokeStyle = COLOR.stroke; ctx.lineWidth = 1; ctx.stroke();
    }
    function text(opts){
      const { str, x, y, size=20, weight=400, color=COLOR.text, align='left', baseline='alphabetic' } = opts;
      ctx.fillStyle = color;
      ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = align; ctx.textBaseline = baseline;
      ctx.fillText(str, x, y);
    }
    function fitNumber(n, maxDp){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6); return n.toLocaleString(undefined, { maximumFractionDigits: dp }); }
    function money(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }); }
    function formatSupplyCompact(n){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      if (abs >= 1e9)  return (n/1e9).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' B';
      if (abs >= 1e6)  return (n/1e6).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' M';
      if (abs >= 1e3)  return (n/1e3).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' K';
      return n.toLocaleString(undefined,{ maximumFractionDigits: 3 });
    }

    function drawBackground(w, h){
      // Base gradient for readability
      const grad = ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');

      const showThumb = USE_THUMB_PLACEHOLDER && thumbBitmap && (!mainBitmap || fadeAlpha < 1);
      const bmp = (bgReady && mainBitmap) ? mainBitmap : (showThumb ? thumbBitmap : null);

      if (bmp){
        const imgW = bmp.width, imgH = bmp.height;
        const scale = (FIT_MODE === 'cover') ? Math.max(w / imgW, h / imgH) : Math.min(w / imgW, h / imgH);
        const dw = imgW * scale; const dh = imgH * scale;
        const dx = (w - dw) / 2; const dy = (h - dh) / 2;
        if (showThumb){ ctx.save(); ctx.filter = 'blur(8px)'; ctx.drawImage(bmp, dx, dy, dw, dh); ctx.restore(); }
        else { ctx.drawImage(bmp, dx, dy, dw, dh); }
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
      } else {
        ctx.fillStyle = '#0b0b12'; ctx.fillRect(0,0,w,h);
      }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const isMobile = w < MOBILE_BREAKPOINT;

      ctx.clearRect(0,0,w,h);
      drawBackground(w, h);
      linkHitboxes = [];

      // Ready?
      const dataReady = !!(burn && price);
      const uiReady = (!!mainBitmap && dataReady);
      if (DRAW_UI_ONLY_WHEN_READY && !uiReady) return;

      // --- Metrics: fit-to-text cards ---
      const labelSize = px(12), labelWeight = 700;
      const valueSize = px(22), valueWeight = 800;
      const padX = px(14), padY = px(10), vGap = px(6);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);

      const label1 = 'Total burned';
      const value1 = `${fitNumber(totalTokens, 6)} BUMPER`;

      const label2 = 'Total USD burned';
      const value2 = money(totalUsd);

      // misura card 1
      ctx.font = `${labelWeight} ${labelSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const c1LabelW = ctx.measureText(label1).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const c1ValueW = ctx.measureText(value1).width;
      const card1W = Math.ceil(Math.max(c1LabelW, c1ValueW) + padX*2);
      const card1H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      // misura card 2
      ctx.font = `${labelWeight} ${labelSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const c2LabelW = ctx.measureText(label2).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const c2ValueW = ctx.measureText(value2).width;
      const card2W = Math.ceil(Math.max(c2LabelW, c2ValueW) + padX*2);
      const card2H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      // ---- Posizioni card
      let card1X, card1Y, card2X, card2Y;

      if (!isMobile) {
        // Desktop: usa le tue frazioni
        let topY = Math.floor(h * CARDS_Y_FRAC);
        // evita l'auto (tetto ~33% h)
        const maxSafeY = Math.floor(h * 0.33 - Math.max(card1H, card2H));
        if (topY > maxSafeY) topY = Math.max(px(8), maxSafeY);

        const c1cx = Math.floor(w * CARD1_CENTER_X_FRAC);
        const c2cx = Math.floor(w * CARD2_CENTER_X_FRAC);
        card1X = c1cx - Math.floor(card1W/2);
        card2X = c2cx - Math.floor(card2W/2);
        card1Y = card2Y = topY;
      } else {
        // Mobile: impilate e centrate
        const centerX = Math.floor(w * 0.5);
        card1X = centerX - Math.floor(card1W/2);
        card1Y = Math.floor(h * MOBILE_CARDS_Y_FRAC);
        card2X = centerX - Math.floor(card2W/2);
        card2Y = card1Y + card1H + px(MOBILE_CARDS_GAP_PX);
      }

      // draw card 1 (label left, value sotto)
      drawGlass(card1X, card1Y, card1W, card1H);
      text({ str: label1, x: card1X + padX, y: card1Y + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, baseline: 'top' });
      text({ str: value1, x: card1X + padX, y: card1Y + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent, baseline: 'top' });

      // draw card 2 (label right, value sotto)
      const c2LabelX = card2X + card2W - padX;
      drawGlass(card2X, card2Y, card2W, card2H);
      text({ str: label2, x: c2LabelX, y: card2Y + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, align: 'right', baseline: 'top' });
      text({ str: value2, x: card2X + padX, y: card2Y + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent2, baseline: 'top' });

      // --- Table & mini-cards ---
      const tableW = Math.min(Math.max(px(420), Math.floor(w*0.92)), px(1000));
      const rowH   = px(24), headH = px(46), tPad = px(10);

      // posizioniamo la tabella in base alle card per evitare sovrapposizioni
      let tableX = Math.floor((w - tableW)/2);
      let tableY = (!isMobile)
        ? Math.floor(h * 0.64)
        : (card2Y + card2H + px(14));  // su mobile subito sotto le card

      // mini-cards sopra tabella
      const miniGap = px(10), miniH = px(42);

      const supplyNum = (price && typeof price.totalSupplyTokensNum === 'number')
        ? price.totalSupplyTokensNum
        : (price && price.totalSupplyTokens ? Number(price.totalSupplyTokens) : 0);
      const supplyStr = `Total supply: ${formatSupplyCompact(supplyNum)}`;
      ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      let meas = ctx.measureText(supplyStr);
      const supplyW = Math.min(Math.max(meas.width + px(24), px(220)), px(360));
      let supplyX = tableX;
      let supplyY = tableY - miniH - miniGap;

      const updated = price?.updatedAt || burn?.updatedAt || null;
      const updatedStr = updated ? `Last updated: ${new Date(updated).toLocaleString()}` : 'Last updated: —';
      meas = ctx.measureText(updatedStr);
      const updW = Math.min(Math.max(meas.width + px(24), px(220)), px(420));
      let updX = tableX + tableW - updW;
      let updY = supplyY;

      // Su mobile, se non ci stanno affiancate, le impiliamo
      if (isMobile && supplyW + updW + px(8) > tableW) {
        // supply sopra, updated sotto
        supplyX = tableX;
        supplyY = tableY - miniH*2 - miniGap*2;
        updX = tableX;
        updY = supplyY + miniH + miniGap;
        // sposta un filo in basso la tabella per non stringere
        tableY = tableY; // già sotto le card, ok
      }

      // calcolo righe tabella che entrano davvero nello spazio rimasto
      // prima disegniamo i box mini, così teniamo conto del loro spazio
      drawGlass(supplyX, supplyY, supplyW, miniH);
      text({ str: supplyStr, x: supplyX + px(12), y: supplyY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.text });

      drawGlass(updX, updY, updW, miniH);
      text({ str: updatedStr, x: updX + px(12), y: updY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.muted });

      // spazio disponibile fino al fondo (margine 12px)
      const avail = (h - 12) - tableY;
      const rowsAll = (burn?.burns || []);
      let rowsFit = Math.floor((avail - (headH + tPad*2)) / rowH);
      rowsFit = Math.max(4, Math.min(rowsFit, (!isMobile ? 20 : 10))); // su mobile max 10, ma almeno 4
      const rows = rowsAll.slice(0, Math.max(0, rowsFit));

      const tableH = headH + Math.max(1, rows.length) * rowH + tPad*2;

      // tabella
      drawGlass(tableX, tableY, tableW, tableH);
      text({ str: 'Recent burns', x: tableX+tPad, y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const headersY = tableY + tPad + px(20);
      text({ str: '#',               x: tableX+tPad+6,                   y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (BUMPER)', x: tableX+tPad+px(32)+8,            y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',     x: tableX+tPad+px(32)+Math.max(px(150), Math.floor(tableW*0.28))+8, y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableW*0.28));

      // Rows
      linkHitboxes = [];
      for (let i=0; i<Math.max(1, rows.length); i++){
        const ry = tableY + headH + tPad + i*rowH;
        if (rows.length === 0){ text({ str: 'No burns found.', x: tableX+tPad, y: ry, size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' }); break; }
        const row = rows[i]; const qty = Number(row.amountUi || 0); const url = row.url || '#';
        text({ str: String(i+1), x: tableX+tPad+6, y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
        text({ str: fitNumber(qty, 6), x: tableX+tPad+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });
        const linkStr = 'Open on Solscan';
        ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
        ctx.fillStyle = COLOR.link; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(linkStr, tableX+tPad+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
        const m2 = ctx.measureText(linkStr);
        linkHitboxes.push({ x: tableX+tPad+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m2.width, h: Math.floor(rowH*0.9), url });
      }

      // --- Bottom price ---
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const label = `BUMPER price: ${priceStr} USD`;
      ctx.font = `700 ${px(16)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const m = ctx.measureText(label);
      const bottomY = Math.floor(h * 0.90);
      const pad2 = px(10), bh = px(34), bw = m.width + pad2*2;
      const bx = Math.floor((w - bw)/2), by = Math.floor(bottomY - bh/2);
      drawGlass(bx, by, bw, bh);
      text({ str: label, x: Math.floor(w/2), y: bottomY+1, size: px(16), weight: 700, align: 'center', baseline: 'middle' });
    }

    // Interactivity
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>
