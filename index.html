<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUMPER Burn — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard for BUMPER on Solana: total burned, USD value, price, and recent burn transactions." />
  <link rel="preload" as="image" href="sfondo.png">
  <style>
    :root{
      /* Positioning tweaks for overlays relative to the background image */
      --top-overlay-top: 18vh;      /* between the car and the legionaries' hands */
      --top-overlay-gap: 2rem;      /* space between the two top metric cards */
      --bottom-overlay-bottom: 8vh; /* near the geckos' feet */

      --content-max: 1200px;

      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;   /* solana-ish green */
      --accent2: #ff5fd2;  /* neon magenta */
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    html, body { margin: 0; }
    /* No scroll: lock the viewport */
    body { overflow: hidden; background: #0b0b12; color: var(--text); }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC = 'sfondo.png';
    const BURN_JSON = 'data/burn.json';
    const PRICE_JSON = 'data/price.json';
    const MAX_ROWS = 50; // recent burns to display

    // Layout anchors (percentages of canvas height)
    let TOP_OVERLAY_Y = 0.18;     // top metrics y (18% of height)
    let BOTTOM_PRICE_Y = 0.90;    // price label baseline y (90% of height)
    let UPDATED_Y = 0.66;         // "last updated" text y

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    // HiDPI support
    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale for crisp rendering
      }
      // Optionally adapt anchors on ultra-wide / mobile
      if (h < 700) {
        TOP_OVERLAY_Y = 0.14;
        UPDATED_Y = 0.62;
        BOTTOM_PRICE_Y = 0.88;
      } else {
        TOP_OVERLAY_Y = 0.18;
        UPDATED_Y = 0.66;
        BOTTOM_PRICE_Y = 0.90;
      }
    }

    // Background image scaled to cover
    const bg = new Image();
    bg.src = BG_SRC;
    let bgReady = false;
    bg.onload = ()=>{ bgReady = true; draw(); };

    // Data state
    let burn = null; // { totalUi, burns: [ { amountUi, url } ], count }
    let price = null; // { priceUsd, burnTotalUsd, updatedAt, ... }

    // Clickable link hitboxes
    let linkHitboxes = []; // { x,y,w,h, url }

    function cacheBust(url){
      const t = Date.now();
      return url + (url.includes('?') ? '&' : '?') + 't=' + t;
    }

    async function loadJson(url){
      const res = await fetch(cacheBust(url), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP '+res.status+' for '+url);
      return res.json();
    }

    async function refreshData(){
      try {
        const [b, p] = await Promise.all([
          loadJson(BURN_JSON).catch(()=>null),
          loadJson(PRICE_JSON).catch(()=>null)
        ]);
        burn = b; price = p;
      } catch (e) {
        console.error(e);
      } finally {
        draw();
      }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, 14);
      ctx.fillStyle = COLOR.glass;
      ctx.fill();
      ctx.strokeStyle = COLOR.stroke;
      ctx.lineWidth = 1;
      ctx.stroke();
      // subtle inner line
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.beginPath();
      ctx.moveTo(x, y+h*0.5);
      ctx.lineTo(x+w, y+h*0.5);
      ctx.strokeStyle = '#fff';
      ctx.stroke();
      ctx.restore();
    }

    function shadow(fn){
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.55)';
      ctx.shadowBlur = 24; ctx.shadowOffsetY = 6;
      fn();
      ctx.restore();
    }

    function text(opts){
      const { str, x, y, size=20, weight=400, color=COLOR.text, align='left', baseline='alphabetic' } = opts;
      ctx.fillStyle = color;
      ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = align; ctx.textBaseline = baseline;
      ctx.fillText(str, x, y);
    }

    function fitNumber(n, maxDp){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6);
      return n.toLocaleString(undefined, { maximumFractionDigits: dp });
    }

    function money(n){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      // Clear
      ctx.clearRect(0,0,w,h);

      // Background cover
      if (bgReady){
        const imgW = bg.naturalWidth || bg.width;
        const imgH = bg.naturalHeight || bg.height;
        const scale = Math.max(w / imgW, h / imgH);
        const dw = imgW * scale;
        const dh = imgH * scale;
        const dx = (w - dw) / 2;
        const dy = (h - dh) / 2;
        ctx.drawImage(bg, dx, dy, dw, dh);
        // subtle dark gradient for readability
        const grad = ctx.createLinearGradient(0,0,0,h);
        grad.addColorStop(0, 'rgba(0,0,0,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);
      }

      linkHitboxes = []; // reset links each frame

      // --- Top metrics (Total burned & USD value) ---
      const topY = h * TOP_OVERLAY_Y;
      const cardW = Math.min(Math.max(320, w*0.28), 520);
      const cardH = 90;
      const gap = Math.min(32, w*0.04);
      const totalX = (w - (cardW*2 + gap)) / 2;
      const usdX = totalX + cardW + gap;

      shadow(()=> drawGlass(totalX, topY, cardW, cardH));
      shadow(()=> drawGlass(usdX,  topY, cardW, cardH));

      // Pull numbers
      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const px = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * px);

      // Labels & values
      const padX = 16, padY = 14;
      text({ str: 'Total burned', x: totalX+padX, y: topY+padY+2, size: 14, color: COLOR.muted, weight: 600, baseline: 'top' });
      text({ str: 'USD value',    x: usdX+padX,   y: topY+padY+2, size: 14, color: COLOR.muted, weight: 600, baseline: 'top' });

      text({ str: fitNumber(totalTokens, 6)+' BUMPER', x: totalX+padX, y: topY+padY+38, size: 28, weight: 800, color: COLOR.accent, baseline: 'top' });
      text({ str: money(totalUsd),               x: usdX+padX,   y: topY+padY+38, size: 28, weight: 800, color: COLOR.accent2, baseline: 'top' });

      // --- Bottom price label ---
      const priceStr = (px ? px.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const label = `BUMPER price: ${priceStr} USD`;
      const m = ctx.measureText(label);
      const bottomY = h * BOTTOM_PRICE_Y;
      shadow(()=>{
        const pad = 10; const bh = 36; const bw = m.width + pad*2;
        const bx = (w - bw)/2; const by = bottomY - bh/2;
        drawGlass(bx, by, bw, bh);
        text({ str: label, x: w/2, y: bottomY+1, size: 18, weight: 700, align: 'center', baseline: 'middle' });
      });

      // --- Last updated ---
      const updated = price?.updatedAt || burn?.updatedAt || null;
      if (updated){
        const u = new Date(updated).toLocaleString();
        text({ str: `Last updated: ${u}`, x: w/2, y: h*UPDATED_Y, size: 14, color: COLOR.muted, weight: 600, align: 'center' });
      }

      // --- Burns table (glass card) ---
      const rows = (burn?.burns || []).slice(0, MAX_ROWS);
      const tableW = Math.min(Math.max(480, w*0.9), 1100);
      const rowH = 30; const headH = 36; const pad = 12;
      const tableH = headH + Math.max(1, rows.length) * rowH + pad*2;
      let tableX = (w - tableW)/2;
      let tableY = h * (UPDATED_Y + 0.03);
      if (tableY + tableH > h - 12) {
        tableY = h - 12 - tableH; // keep on screen
      }

      shadow(()=> drawGlass(tableX, tableY, tableW, tableH));

      // Header
      text({ str: 'Recent burns', x: tableX+pad, y: tableY+pad+2, size: 14, color: COLOR.muted, weight: 700, baseline: 'top' });

      // Columns
      const colIndexW = 40; // #
      const colQtyW   = Math.max(180, tableW*0.30);
      const colLinkW  = tableW - pad*2 - colIndexW - colQtyW;

      const y0 = tableY + headH + pad;
      // header titles
      text({ str: '#',                x: tableX+pad+8,                 y: tableY+pad+2, size: 14, color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: 'Amount (BUMPER)',  x: tableX+pad+colIndexW+10,      y: tableY+pad+2, size: 14, color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: 'Transaction',      x: tableX+pad+colIndexW+colQtyW+10, y: tableY+pad+2, size: 14, color: COLOR.muted, weight: 700, baseline: 'top' });

      // rows
      ctx.save();
      for (let i=0; i<Math.max(1, rows.length); i++){
        const ry = y0 + i*rowH;
        if (rows.length === 0){
          text({ str: 'No burns found.', x: tableX+pad, y: ry, size: 16, color: COLOR.muted, weight: 600, baseline: 'top' });
          break;
        }
        const row = rows[i];
        const qty = Number(row.amountUi || 0);
        const url = row.url || '#';

        // index
        text({ str: String(i+1), x: tableX+pad+8, y: ry+10, size: 14, color: COLOR.text, weight: 600, baseline: 'alphabetic' });
        // quantity
        text({ str: fitNumber(qty, 6), x: tableX+pad+colIndexW+10, y: ry+10, size: 16, color: COLOR.text, weight: 700 });
        // link
        const linkStr = 'Open on Solscan';
        ctx.font = `600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
        ctx.fillStyle = COLOR.link;
        ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(linkStr, tableX+pad+colIndexW+colQtyW+10, ry+10);
        const m = ctx.measureText(linkStr);
        linkHitboxes.push({
          x: tableX+pad+colIndexW+colQtyW+10,
          y: ry - 6,
          w: m.width,
          h: 22,
          url
        });
      }
      ctx.restore();
    }

    // Interactivity: make Solscan links clickable
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) {
        window.open(hit.url, '_blank', 'noopener');
      }
    });

    // Initial load & timers
    window.addEventListener('resize', draw);
    refreshData();
    // Optional: refresh data every 5 min without scrolling
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>
