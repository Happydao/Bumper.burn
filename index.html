<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUMPER Burn — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard for BUMPER on Solana: total burned, USD value, price, and recent burn transactions." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <link rel="preload" as="image" href="bg-thumb.webp">
  <link rel="preload" as="image" href="titolotr.png">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC      = 'bg-desktop.png';       // main background
    const THUMB_SRC   = 'bg-thumb.webp';        // small preview (optional)
    const TITLE_SRC   = 'titolotr.png';         // title image (trimmed to remove transparent padding)

    const BURN_JSON   = 'data/burn.json';
    const PRICE_JSON  = 'data/price.json';
    const FIT_MODE    = 'cover'; // 'contain' to avoid any crop

    // Draw UI only when everything is ready (bg + title + data)
    const DRAW_UI_ONLY_WHEN_READY = true;
    const USE_THUMB_PLACEHOLDER   = false; // if true, shows blurred thumb before HD bg

    // Layout anchors
    let TOP_OVERLAY_Y   = 0.12; // y for the two top cards
    let BOTTOM_PRICE_Y  = 0.90;

    // Title placement (top center)
    let TITLE_TOP_MARGIN_PX = -80;

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    // Canvas
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      TOP_OVERLAY_Y = (h < 700) ? 0.10 : 0.12;
    }

    function scaleUnit() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      return Math.max(0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // --- Quick tuning via URL: ?ty=-20&cardsY=14 (14%) ---
    (function applyQueryTweaks(){
      try {
        const qs = new URLSearchParams(location.search);
        const ty = Number(qs.get('ty'));
        if (!Number.isNaN(ty)) TITLE_TOP_MARGIN_PX = ty;
        const cardsY = Number(qs.get('cardsY'));
        if (!Number.isNaN(cardsY)) TOP_OVERLAY_Y = Math.min(0.30, Math.max(0.05, cardsY/100));
      } catch {}
    })();

    // -------- Progressive background loading (blur-up + crossfade) --------
    let thumbBitmap = null;
    let mainBitmap  = null;
    let titleTrim   = null; // {top,bottom,left,right}
    let bgReady = false;
    let fadeAlpha = 0; // 0..1

    async function loadBitmap(src){
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      } catch (e) {
        console.warn('Image load failed:', src, e.message);
        return null;
      }
    }

    // Title image (auto-trim transparent padding)
    const titleImg = new Image();
    let titleReady = false;
    titleImg.onload = ()=>{
      try {
        const iw = titleImg.naturalWidth, ih = titleImg.naturalHeight;
        const off = document.createElement('canvas');
        off.width = iw; off.height = ih;
        const octx = off.getContext('2d');
        octx.drawImage(titleImg, 0, 0);
        const { data } = octx.getImageData(0,0,iw,ih);
        const alphaAt = (x,y)=> data[(y*iw + x)*4 + 3];
        let top=0, bottom=ih-1, left=0, right=iw-1;
        for (let y=0; y<ih; y++){ for (let x=0; x<iw; x++){ if (alphaAt(x,y) > 8){ top=y; y=ih; break; } } }
        for (let y=ih-1; y>=0; y--){ for (let x=0; x<iw; x++){ if (alphaAt(x,y) > 8){ bottom=y; y=-1; break; } } }
        for (let x=0; x<iw; x++){ for (let y=0; y<ih; y++){ if (alphaAt(x,y) > 8){ left=x; x=iw; break; } } }
        for (let x=iw-1; x>=0; x--){ for (let y=0; y<ih; y++){ if (alphaAt(x,y) > 8){ right=x; x=-1; break; } } }
        titleTrim = { top, bottom: ih-1-bottom, left, right: iw-1-right };
      } catch(e){ console.warn('Title trim failed', e); titleTrim = null; }
      titleReady = true; draw();
    };
    titleImg.onerror = ()=>{ console.warn('Failed to load title image:', TITLE_SRC); };
    titleImg.src = TITLE_SRC;

    // Load bg: thumb (optional) then main
    (async function initBackground(){
      thumbBitmap = await loadBitmap(THUMB_SRC); // may be null
      draw();
      mainBitmap = await loadBitmap(BG_SRC);
      if (mainBitmap) {
        bgReady = true;
        const start = performance.now();
        function step(t){
          const k = Math.min(1, (t - start) / 450);
          fadeAlpha = k; draw();
          if (k < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      } else { draw(); }
    })();

    // Data
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, totalSupplyTokensNum/totalSupplyTokens, updatedAt? }

    let linkHitboxes = [];

    function cacheBust(url){ return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); }
    async function loadJson(url){ const res = await fetch(cacheBust(url), { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.json(); }
    async function refreshData(){
      try { const [b, p] = await Promise.all([ loadJson(BURN_JSON).catch(()=>null), loadJson(PRICE_JSON).catch(()=>null) ]); burn = b; price = p; }
      catch(e){ console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath(); ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, px(12));
      ctx.fillStyle = COLOR.glass; ctx.fill();
      ctx.strokeStyle = COLOR.stroke; ctx.lineWidth = 1; ctx.stroke();
    }
    function text(opts){
      const { str, x, y, size=20, weight=400, color=COLOR.text, align='left', baseline='alphabetic' } = opts;
      ctx.fillStyle = color;
      ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = align; ctx.textBaseline = baseline;
      ctx.fillText(str, x, y);
    }
    function fitNumber(n, maxDp){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6); return n.toLocaleString(undefined, { maximumFractionDigits: dp }); }
    function money(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }); }
    function formatSupplyCompact(n){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      if (abs >= 1e9)  return (n/1e9).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' B';
      if (abs >= 1e6)  return (n/1e6).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' M';
      if (abs >= 1e3)  return (n/1e3).toLocaleString(undefined,{ maximumFractionDigits: 3 }) + ' K';
      return n.toLocaleString(undefined,{ maximumFractionDigits: 3 });
    }

    function drawBackground(w, h){
      // Base gradient for readability
      const grad = ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');

      const showThumb = USE_THUMB_PLACEHOLDER && thumbBitmap && (!mainBitmap || fadeAlpha < 1);
      const bmp = (bgReady && mainBitmap) ? mainBitmap : (showThumb ? thumbBitmap : null);

      if (bmp){
        const imgW = bmp.width, imgH = bmp.height;
        const scale = (FIT_MODE === 'cover') ? Math.max(w / imgW, h / imgH) : Math.min(w / imgW, h / imgH);
        const dw = imgW * scale; const dh = imgH * scale;
        const dx = (w - dw) / 2; const dy = (h - dh) / 2;
        if (showThumb){ ctx.save(); ctx.filter = 'blur(8px)'; ctx.drawImage(bmp, dx, dy, dw, dh); ctx.restore(); }
        else { ctx.drawImage(bmp, dx, dy, dw, dh); }
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
      } else {
        ctx.fillStyle = '#0b0b12'; ctx.fillRect(0,0,w,h);
      }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;

      ctx.clearRect(0,0,w,h);
      drawBackground(w, h);
      linkHitboxes = [];

      // Wait until bg + title + data are ready
      const dataReady = !!(burn && price);
      const uiReady = (!!mainBitmap && !!titleReady && dataReady);
      if (DRAW_UI_ONLY_WHEN_READY && !uiReady) return;

      // --- Title image at top center ---
      if (titleReady){
        if (titleTrim){
          const srcX = titleTrim.left || 0;
          const srcY = titleTrim.top  || 0;
          const srcW = titleImg.naturalWidth  - (titleTrim.left||0) - (titleTrim.right||0);
          const srcH = titleImg.naturalHeight - (titleTrim.top ||0) - (titleTrim.bottom||0);
          const maxW = Math.min(w * 0.55, px(760));
          const scale = maxW / srcW;
          const tw = maxW; const th = srcH * scale;
          const tx = Math.floor((w - tw) / 2);
          const ty = px(TITLE_TOP_MARGIN_PX);
          ctx.drawImage(titleImg, srcX, srcY, srcW, srcH, tx, ty, tw, th);
        } else {
          const maxW = Math.min(w * 0.55, px(760));
          const scale = maxW / titleImg.naturalWidth;
          const tw = maxW; const th = titleImg.naturalHeight * scale;
          const tx = Math.floor((w - tw) / 2);
          const ty = px(TITLE_TOP_MARGIN_PX);
          ctx.drawImage(titleImg, tx, ty, tw, th);
        }
      }

      // --- Top metrics (two cards) ---
      const topY = Math.floor(h * TOP_OVERLAY_Y);
      const cardW = Math.min(Math.max(px(300), Math.floor(w*0.28)), px(520));
      const cardH = px(84);
      const gap   = Math.min(px(24), Math.floor(w*0.04));
      const totalX = Math.floor((w - (cardW*2 + gap)) / 2);
      const usdX   = totalX + cardW + gap;

      drawGlass(totalX, topY, cardW, cardH);
      drawGlass(usdX,  topY, cardW, cardH);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);

      const padX = px(14), padY = px(12);
      text({ str: 'Total burned',        x: totalX+padX, y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: 'Total USD burned',    x: usdX+padX,   y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });

      text({ str: fitNumber(totalTokens, 6)+' BUMPER', x: totalX+padX, y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent,  baseline: 'top' });
      text({ str: money(totalUsd),                  x: usdX+padX,   y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent2, baseline: 'top' });

      // --- Compute table layout ---
      const rowsAll = (burn?.burns || []);
      const maxRows = w < 520 ? 8 : (w < 900 ? 12 : 20);
      const rows = rowsAll.slice(0, maxRows);

      const tableW = Math.min(Math.max(px(420), Math.floor(w*0.92)), px(1000));
      const rowH   = px(24), headH = px(46), tPad = px(10);
      const tableH = headH + Math.max(1, rows.length) * rowH + tPad*2;
      let tableX = Math.floor((w - tableW)/2);
      let tableY = Math.floor(h * 0.64); // just below the car
      if (tableY + tableH > h - 12) tableY = h - 12 - tableH;

      // --- Mini-cards above table: Supply (left) and Last updated (right) ---
      const miniGap = px(10);
      const miniH = px(42);

      // Supply
      const supplyNum = (price && typeof price.totalSupplyTokensNum === 'number')
        ? price.totalSupplyTokensNum
        : (price && price.totalSupplyTokens ? Number(price.totalSupplyTokens) : 0);
      const supplyStr = `Total supply: ${formatSupplyCompact(supplyNum)}`;
      ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      let meas = ctx.measureText(supplyStr);
      const supplyW = Math.min(Math.max(meas.width + px(24), px(220)), px(360));
      const supplyX = tableX;
      const supplyY = tableY - miniH - miniGap;
      drawGlass(supplyX, supplyY, supplyW, miniH);
      text({ str: supplyStr, x: supplyX + px(12), y: supplyY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.text });

      // Last updated
      const updated = price?.updatedAt || burn?.updatedAt || null;
      const updatedStr = updated ? `Last updated: ${new Date(updated).toLocaleString()}` : 'Last updated: —';
      meas = ctx.measureText(updatedStr);
      const updW = Math.min(Math.max(meas.width + px(24), px(220)), px(420));
      const updX = tableX + tableW - updW;
      const updY = supplyY;
      drawGlass(updX, updY, updW, miniH);
      text({ str: updatedStr, x: updX + px(12), y: updY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.muted });

      // --- Draw table ---
      drawGlass(tableX, tableY, tableW, tableH);
      text({ str: 'Recent burns', x: tableX+tPad, y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      // Column headers placed lower than the section title
      const headersY = tableY + tPad + px(20);
      text({ str: '#',               x: tableX+tPad+6,                   y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (BUMPER)', x: tableX+tPad+px(32)+8,            y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',     x: tableX+tPad+px(32)+Math.max(px(150), Math.floor(tableW*0.28))+8, y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableW*0.28));
      const colLinkW  = tableW - tPad*2 - colIndexW - colQtyW;

      // Rows
      linkHitboxes = [];
      for (let i=0; i<Math.max(1, rows.length); i++){
        const ry = tableY + headH + tPad + i*rowH;
        if (rows.length === 0){ text({ str: 'No burns found.', x: tableX+tPad, y: ry, size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' }); break; }
        const row = rows[i]; const qty = Number(row.amountUi || 0); const url = row.url || '#';
        text({ str: String(i+1), x: tableX+tPad+6, y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
        text({ str: fitNumber(qty, 6), x: tableX+tPad+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });
        const linkStr = 'Open on Solscan';
        ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
        ctx.fillStyle = COLOR.link; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(linkStr, tableX+tPad+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
        const m2 = ctx.measureText(linkStr);
        linkHitboxes.push({ x: tableX+tPad+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m2.width, h: Math.floor(rowH*0.9), url });
      }

      // --- Bottom price ---
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const label = `BUMPER price: ${priceStr} USD`;
      ctx.font = `700 ${px(16)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const m = ctx.measureText(label);
      const bottomY = Math.floor(h * BOTTOM_PRICE_Y);
      const pad2 = px(10), bh = px(34), bw = m.width + pad2*2;
      const bx = Math.floor((w - bw)/2), by = Math.floor(bottomY - bh/2);
      drawGlass(bx, by, bw, bh);
      text({ str: label, x: Math.floor(w/2), y: bottomY+1, size: px(16), weight: 700, align: 'center', baseline: 'middle' });
    }

    // Interactivity
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>
