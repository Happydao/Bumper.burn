<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUMPER Burn — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard for BUMPER on Solana: total burned, USD value, price, and recent burn transactions." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config (FIXED) ----
    const BG_SRC     = 'bg-desktop.png';   // <== PNG file you added
    const BURN_JSON  = 'data/burn.json';   // correct var name
    const PRICE_JSON = 'data/price.json';
    const FIT_MODE   = 'cover';            // use 'contain' to avoid any crop

    // Layout anchors (relative to canvas height)
    let TOP_OVERLAY_Y = 0.18;   // top metrics Y (18% of height)
    let BOTTOM_PRICE_Y = 0.90;  // bottom price baseline Y
    let UPDATED_Y = 0.66;       // last updated text Y

    // Colors from CSS custom props (fallbacks included)
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    // Canvas setup (no scroll)
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      if (h < 700) { TOP_OVERLAY_Y = 0.14; UPDATED_Y = 0.60; BOTTOM_PRICE_Y = 0.88; }
      else { TOP_OVERLAY_Y = 0.18; UPDATED_Y = 0.66; BOTTOM_PRICE_Y = 0.90; }
    }

    // Responsive scale helper
    function scaleUnit() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      return Math.max(0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // Background image
    const bg = new Image();
    let bgReady = false;
    bg.onload  = ()=>{ bgReady = true; draw(); };
    bg.onerror = ()=>{ console.error('Failed to load background:', BG_SRC); bgReady = false; draw(); };
    bg.src = BG_SRC;

    // Data state
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, updatedAt? }

    // Clickable link hitboxes
    let linkHitboxes = []; // { x,y,w,h,url }

    function cacheBust(url){
      return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
    }
    async function loadJson(url){
      const res = await fetch(cacheBust(url), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP '+res.status+' for '+url);
      return res.json();
    }
    async function refreshData(){
      try {
        const [b, p] = await Promise.all([
          loadJson(BURN_JSON).catch(()=>null),
          loadJson(PRICE_JSON).catch(()=>null)
        ]);
        burn = b; price = p;
      } catch (e) { console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, px(12));
      ctx.fillStyle = COLOR.glass;
      ctx.fill();
      ctx.strokeStyle = COLOR.stroke;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    function text(opts){
      const { str, x, y, size=20, weight=400, color=COLOR.text, align='left', baseline='alphabetic' } = opts;
      ctx.fillStyle = color;
      ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = align; ctx.textBaseline = baseline;
      ctx.fillText(str, x, y);
    }
    function fitNumber(n, maxDp){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6);
      return n.toLocaleString(undefined, { maximumFractionDigits: dp });
    }
    function money(n){
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });
    }

    function drawBackground(w, h){
      // Base gradient always rendered
      const grad = ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');

      if (bgReady){
        const imgW = bg.naturalWidth || bg.width;
        const imgH = bg.naturalHeight || bg.height;
        const scale = (FIT_MODE === 'cover') ? Math.max(w / imgW, h / imgH) : Math.min(w / imgW, h / imgH);
        const dw = imgW * scale;
        const dh = imgH * scale;
        const dx = (w - dw) / 2;
        const dy = (h - dh) / 2;
        ctx.drawImage(bg, dx, dy, dw, dh);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);
      } else {
        // Fallback solid background if image not loaded
        ctx.fillStyle = '#0b0b12';
        ctx.fillRect(0,0,w,h);
      }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;

      // Clear + background
      ctx.clearRect(0,0,w,h);
      drawBackground(w, h);

      linkHitboxes = [];

      // --- Top metrics ---
      const topY = Math.floor(h * TOP_OVERLAY_Y);
      const cardW = Math.min(Math.max(px(300), Math.floor(w*0.28)), px(520));
      const cardH = px(84);
      const gap   = Math.min(px(24), Math.floor(w*0.04));
      const totalX = Math.floor((w - (cardW*2 + gap)) / 2);
      const usdX   = totalX + cardW + gap;

      drawGlass(totalX, topY, cardW, cardH);
      drawGlass(usdX,  topY, cardW, cardH);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);

      const padX = px(14), padY = px(12);
      text({ str: 'Total burned', x: totalX+padX, y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });
      text({ str: 'USD value',    x: usdX+padX,   y: topY+padY+2, size: px(12), color: COLOR.muted, weight: 700, baseline: 'top' });

      text({ str: fitNumber(totalTokens, 6)+' BUMPER', x: totalX+padX, y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent, baseline: 'top' });
      text({ str: money(totalUsd),                 x: usdX+padX,   y: topY+padY+px(32), size: px(22), weight: 800, color: COLOR.accent2, baseline: 'top' });

      // --- Bottom price ---
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const label = `BUMPER price: ${priceStr} USD`;
      ctx.font = `700 ${px(16)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const m = ctx.measureText(label);
      const bottomY = Math.floor(h * BOTTOM_PRICE_Y);
      const pad = px(10), bh = px(34), bw = m.width + pad*2;
      const bx = Math.floor((w - bw)/2), by = Math.floor(bottomY - bh/2);
      drawGlass(bx, by, bw, bh);
      text({ str: label, x: Math.floor(w/2), y: bottomY+1, size: px(16), weight: 700, align: 'center', baseline: 'middle' });

      // --- Last updated ---
      const updated = price?.updatedAt || burn?.updatedAt || null;
      if (updated){
        const u = new Date(updated).toLocaleString();
        text({ str: `Last updated: ${u}`, x: Math.floor(w/2), y: Math.floor(h*UPDATED_Y), size: px(12), color: COLOR.muted, weight: 700, align: 'center' });
      }

      // --- Burns table ---
      const rowsAll = (burn?.burns || []);
      const maxRows = w < 520 ? 8 : (w < 900 ? 12 : 20);
      const rows = rowsAll.slice(0, maxRows);

      const tableW = Math.min(Math.max(px(420), Math.floor(w*0.92)), px(1000));
      const rowH   = px(24), headH = px(32), tPad = px(10);
      const tableH = headH + Math.max(1, rows.length) * rowH + tPad*2;
      let tableX = Math.floor((w - tableW)/2);
      let tableY = Math.floor(h * (UPDATED_Y + 0.03));
      if (tableY + tableH > h - 12) tableY = h - 12 - tableH;

      drawGlass(tableX, tableY, tableW, tableH);

      text({ str: 'Recent burns', x: tableX+tPad, y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableW*0.28));
      const colLinkW  = tableW - tPad*2 - colIndexW - colQtyW;

      // headers
      text({ str: '#',               x: tableX+tPad+6,                      y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (BUMPER)', x: tableX+tPad+colIndexW+8,            y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',     x: tableX+tPad+colIndexW+colQtyW+8,    y: tableY+tPad+2, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      // rows & link hitboxes
      linkHitboxes = [];
      for (let i=0; i<Math.max(1, rows.length); i++){
        const ry = tableY + headH + tPad + i*rowH;
        if (rows.length === 0){
          text({ str: 'No burns found.', x: tableX+tPad, y: ry, size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' });
          break;
        }
        const row = rows[i];
        const qty = Number(row.amountUi || 0);
        const url = row.url || '#';

        text({ str: String(i+1), x: tableX+tPad+6, y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
        text({ str: fitNumber(qty, 6), x: tableX+tPad+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });

        const linkStr = 'Open on Solscan';
        ctx.font = `700 ${px(12)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
        ctx.fillStyle = COLOR.link;
        ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(linkStr, tableX+tPad+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
        const m = ctx.measureText(linkStr);
        linkHitboxes.push({ x: tableX+tPad+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m.width, h: Math.floor(rowH*0.9), url });
      }
    }

    // Interactivity for Solscan links
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    // Initial load & timers
    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>
